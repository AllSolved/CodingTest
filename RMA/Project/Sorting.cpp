#include "Sorting.h"
#include <vector>
#include <iostream>

void SelectionSort()
{
	std::vector<int> arr{ 7,5,9,0,3,1,6,2,4,8 };

	int arrSize = (int)arr.size();				// 배열의 총 사이즈
	int minIndex = 0;							// 가장 작은 값을 가지고 있는 인덱스
	
	std::cout << "정렬 전 : ";

	for (int i = 0; i < arrSize; ++i)
	{
		std::cout << arr[i] << " ";
	}

	std::cout << '\n';

	// 배열 탐색
	for (int frontIndex = 0; frontIndex < arrSize; ++frontIndex)
	{
		minIndex = frontIndex;

		// 현재 제일 작은 인덱스의 값보다 더 작은 값을 발견하면 교체
		for (int compareIndex = frontIndex + 1; compareIndex < arrSize; compareIndex++)
		{
			if (arr[minIndex] > arr[compareIndex])
				minIndex = compareIndex;
		}
		
		// 값 순서 변경
		int smallestValue = arr[minIndex];		
		arr[minIndex] = arr[frontIndex];
		arr[frontIndex] = smallestValue;
	}

	std::cout << "정렬 후 : ";

	for (int i = 0; i < arrSize; ++i)
	{
		std::cout  << arr[i] << " " ;
	}
}

void InsertionSort()
{
	int arr[10] = { 7,5,9,0,3,1,6,2,4,8 };

	int arrSize = 10;				// 배열의 총 사이즈
	int minIndex = 0;				// 가장 작은 값을 가지고 있는 인덱스

	std::cout << "정렬 전 : ";

	for (int i = 0; i < arrSize; ++i)
	{
		std::cout << arr[i] << " ";
	}

	std::cout << '\n';

	// 삽입 정렬은 두번째 인덱스 부터 시작함 (첫번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문) 
	for (int currentIndex = 1; currentIndex < arrSize; ++currentIndex)
	{
		// 현재 인덱스의 값
		int currentValue = arr[currentIndex];

		// 자신보다 작은 인덱스를 순회하며 현재 데이터의 자리를 찾는다.
		for (int compareIndex = currentIndex-1 ; compareIndex >= 0; --compareIndex)
		{
			int compareValue = arr[compareIndex];

			// currentValue가 비교할 값보다 더 작다면 위치를 옮긴다
			if (currentValue < compareValue)
			{
				arr[compareIndex + 1] = compareValue;
				arr[compareIndex] = currentValue;
			}
			
			// currentValue가 더 크다면 그대로 멈춘다.
			else
			{
				break;
			}

		}
	}

	std::cout << "정렬 후 : ";


	for (int i = 0; i < arrSize; ++i)
	{
		std::cout << arr[i] << " ";
	}
}

void QuickSort()
{
	int arr[10] = { 5,7,9,0,3,1,6,2,4,8 };

	int arrSize = 10;				// 배열의 총 사이즈

	std::cout << "정렬 전 : ";

	for (int i = 0; i < arrSize; ++i)
	{
		std::cout << arr[i] << " ";
	}
	std::cout << '\n';

	// 피봇을 지정
	int pivotValue = arr[0];
	int leftIndex = 1;
	int rightIndex = arrSize - 1;
	
	// 왼쪽에부터 피봇보다 큰 데이터를 고르고, 오른쪽에서부터 피봇보다 작은 데이터를 선택한다.

	while (leftIndex <= rightIndex)
	{
		while (leftIndex < arrSize && (arr[leftIndex] <= pivotValue))
		{
			++leftIndex;
		}

		while (rightIndex > 0 && (arr[rightIndex] >= pivotValue))
		{
			--rightIndex;

		}

		int leftValue = arr[leftIndex];
		int rightValue = arr[rightIndex];

		// 인덱스가 엇갈렸을 경우 작은쪽의 데이터를 pivot으로 바꿔준다
		if (leftIndex > rightIndex)
		{
			arr[0] = rightValue;
			arr[rightIndex] = pivotValue;
		}

		else
		{
			arr[leftIndex] = rightValue;
			arr[rightIndex] = leftValue;
		}
	}

	std::cout << "분할 정렬 : ";

	for (int i = 0; i < arrSize; ++i)
	{
		std::cout << arr[i] << " ";
	}

	std::cout << '\n';

	// 위의 정렬 과정을 좌, 우로 나눠서 반복한다.
}

void QuickSort(int* arrData, int startIndex, int endIndex)
{
	if (startIndex >= endIndex)
	{
		return;
	}


	// 피봇을 지정
	int pivotValue = arrData[startIndex];
	int leftIndex = startIndex+1;
	int rightIndex = endIndex;
	
	// 왼쪽에부터 피봇보다 큰 데이터를 고르고, 오른쪽에서부터 피봇보다 작은 데이터를 선택한다.

	while (leftIndex <= rightIndex)
	{
		while (leftIndex <= endIndex && (arrData[leftIndex] <= pivotValue))
		{
			++leftIndex;
		}

		while (rightIndex > startIndex && (arrData[rightIndex] >= pivotValue))
		{
			--rightIndex;

		}

		int leftValue = arrData[leftIndex];
		int rightValue = arrData[rightIndex];

		// 인덱스가 엇갈렸을 경우 작은쪽의 데이터를 pivot으로 바꿔준다
		if (leftIndex > rightIndex)
		{
			arrData[startIndex] = rightValue;
			arrData[rightIndex] = pivotValue;
		}

		else
		{
			arrData[leftIndex] = rightValue;
			arrData[rightIndex] = leftValue;
		}
	}

	// 위의 정렬 과정을 좌, 우로 나눠서 반복한다.

	QuickSort(arrData, startIndex, rightIndex -1);
	QuickSort(arrData, leftIndex+1, endIndex);

}
